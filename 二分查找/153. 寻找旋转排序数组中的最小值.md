
---

### **核心特性：二段性**

旋转后的数组具有**两个升序子数组**，且**前半段所有元素 ≥ 后半段所有元素**：

```
[4,5,6,7]  和  [1,2,3]  
  ↑升序↑        ↑升序↑  
前半段 > 后半段（7 > 1）
```

- **关键性质**：
    - 前半段的最大值（`7`） **>** 后半段的最小值（`1`）
    - 后半段的所有元素 **<** 前半段的所有元素

---

### **为什么这个特性支持二分查找？**

通过比较 `nums[mid]` 和 `nums[right]`，可以判断**最小值在左半还是右半**：
```
nums[right] 是后半段的最大值
```

#### **情况 1：`nums[mid] > nums[right]` → 最小值在右半**

- **原因**：`mid` 位于前半段（较大的升序段），而最小值一定在后半段（较小的升序段）。
- **示例**：`[4,5,6,7,1,2,3]`，`mid=3`（值 `7`）
    - `7 > 3` → 最小值 `1` 在右半（索引 `4-6`）

#### **情况 2：`nums[mid] <= nums[right]` → 最小值在左半（含 `mid`）**

- **原因**：`mid` 位于后半段（较小的升序段），最小值在 `mid` 左侧或就是 `mid`。
- **示例**：`[6,7,1,2,3,4,5]`，`mid=3`（值 `2`）
    - `2 < 5` → 最小值 `1` 在左半（索引 `0-3`）

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        #寻找最小的数即是寻找顺序的开始
        #使用双闭区间的二分
        left = 0 
        right = len(nums)-1
        #一开始写写成O（n）复杂度 ， 没有使用旋转数组中利用二分判断二段性中的大小段的特性
        # while nums[left] >nums[right]:
        #     left +=1
        #     if nums[left] <nums[right]:
        #         break
        # return nums[left]

        while left < right :
            mid = (left +right) // 2
            if nums[mid] >nums[right]:#利用二段性中最有一个元素就是第二段的最大值 ， 如果mid值大于nums[right] ， 那么可以确定后面那段是数值偏小的段 ， 那么最小值就在mid到right之间 ，反之亦然
                left  = mid +1
            else:
                right  = mid  
        return nums[left]
```